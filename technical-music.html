<!doctype html>
<html lang="id">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Technical Deep Dive: Music Feature • Ilham</title>
    <meta
      name="description"
      content="Dokumentasi teknis fitur playlist musik otomatis menggunakan Python dan SpotDL."
    />
    <link rel="stylesheet" href="styles.css" />
    <style>
      .tech-header {
        display: flex;
        align-items: center;
        gap: 1rem;
        margin-bottom: 2rem;
      }
      .tech-content h3 {
        margin-top: 2rem;
        color: var(--accent);
        font-size: 1.2rem;
      }
      .code-block {
        background: #0d1117;
        border: 1px solid #30363d;
        border-radius: 12px;
        padding: 1rem;
        overflow-x: auto;
        font-family: 'SF Mono', 'Segoe UI Mono', 'Roboto Mono', monospace;
        font-size: 0.9rem;
        line-height: 1.5;
        color: #e6edf3;
        margin: 1rem 0;
      }
      .code-comment { color: #8b949e; }
      .code-keyword { color: #ff7b72; }
      .code-func { color: #d2a8ff; }
      .code-str { color: #a5d6ff; }
      .code-var { color: #79c0ff; }

      .diagram {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        margin: 2rem 0;
        align-items: center;
      }
      .diagram-step {
        background: #161b22;
        border: 1px solid #30363d;
        padding: 1rem 2rem;
        border-radius: 8px;
        text-align: center;
        width: 100%;
        max-width: 400px;
        position: relative;
      }
      .diagram-arrow {
        color: var(--accent);
        font-size: 1.5rem;
      }

      .back-btn {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        color: var(--muted);
        text-decoration: none;
        font-weight: 600;
        margin-bottom: 1rem;
        transition: color 0.2s;
      }
      .back-btn:hover {
        color: var(--text);
      }
    </style>
  </head>
  <body>
    <div class="bg-animation">
      <div class="blob blob-1"></div>
      <div class="blob blob-2"></div>
      <div class="blob blob-3"></div>
    </div>
    <div class="noise-overlay"></div>
    <div class="wrap">
      <div class="card" role="main">
        <a href="index.html" class="back-btn">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 12H5M12 19l-7-7 7-7"/></svg>
          Kembali ke Beranda
        </a>

        <header class="tech-header">
          <div>
            <h1>Technical Deep Dive: <span class="grad">Music Automation</span></h1>
            <p class="tagline">Bagaimana Python & SpotDL mengotomatisasi playlist musik di web statis.</p>
          </div>
        </header>

        <div class="tech-content">
          <section>
            <h3>1. Latar Belakang Masalah</h3>
            <p>
              Menampilkan playlist musik di website statis (seperti GitHub Pages) biasanya memiliki keterbatasan:
            </p>
            <ul class="about-list">
              <li>Harus mengunggah file MP3 secara manual (berat & melanggar hak cipta).</li>
              <li>Embed Spotify standar hanya memutar preview 30 detik (kecuali login).</li>
              <li>Tidak dinamis, sulit diupdate.</li>
            </ul>
            <p>
              Solusinya adalah membangun sistem <strong>Hybrid</strong>: Frontend statis yang berkomunikasi dengan Backend Python untuk mengambil stream audio secara <em>on-the-fly</em>.
            </p>
          </section>

          <section>
            <h3>2. Arsitektur Sistem</h3>
            <p>Alur kerja data dari URL Spotify hingga menjadi audio yang bisa didengar:</p>
            <div class="diagram">
              <div class="diagram-step">
                <strong>1. Client (Browser)</strong><br>
                <span class="note">Membaca data/url.txt</span>
              </div>
              <div class="diagram-arrow">↓</div>
              <div class="diagram-step">
                <strong>2. Python Backend API</strong><br>
                <span class="note">Flask + SpotDL (di Zeabur)</span>
              </div>
              <div class="diagram-arrow">↓</div>
              <div class="diagram-step">
                <strong>3. Metadata & Audio Resolver</strong><br>
                <span class="note">Mencari match terbaik di YouTube Music</span>
              </div>
              <div class="diagram-arrow">↓</div>
              <div class="diagram-step">
                <strong>4. Response & Caching</strong><br>
                <span class="note">JSON dikirim balik & disimpan di LocalStorage</span>
              </div>
            </div>
          </section>

          <section>
            <h3>3. Python Backend Logic</h3>
            <p>
              Di sisi server, skrip Python bekerja sebagai "Engine" utama. Menggunakan library <code>spotdl</code>, server menerima URL Spotify, mencari metadata lagu yang sesuai, dan mengembalikan URL streaming yang valid.
            </p>
            <p>Berikut adalah representasi logika backend tersebut:</p>

            <div class="code-block">
<pre><code><span class="code-comment"># backend/app.py (Simplified)</span>
<span class="code-keyword">from</span> flask <span class="code-keyword">import</span> Flask, request, jsonify
<span class="code-keyword">from</span> spotdl <span class="code-keyword">import</span> Spotdl

app = Flask(__name__)

<span class="code-comment"># Inisialisasi SpotDL dengan Client ID & Secret</span>
spotdl_client = Spotdl(
    client_id=<span class="code-str">"YOUR_SPOTIFY_ID"</span>,
    client_secret=<span class="code-str">"YOUR_SPOTIFY_SECRET"</span>
)

<span class="code-func">@app.route</span>(<span class="code-str">"/api/meta"</span>)
<span class="code-keyword">def</span> <span class="code-func">get_metadata</span>():
    url = request.args.get(<span class="code-str">'url'</span>)

    <span class="code-keyword">try</span>:
        <span class="code-comment"># 1. Cari metadata lagu berdasarkan URL Spotify</span>
        songs = spotdl_client.search([url])
        song = songs[0]

        <span class="code-comment"># 2. Dapatkan URL download/stream (biasanya dari YouTube Music)</span>
        <span class="code-comment"># SpotDL menangani pencocokan durasi & artis secara otomatis</span>
        stream_url = song.download_url

        <span class="code-keyword">return</span> jsonify({
            <span class="code-str">"title"</span>: song.name,
            <span class="code-str">"artist"</span>: song.artist,
            <span class="code-str">"audioUrl"</span>: stream_url,
            <span class="code-str">"thumbnail"</span>: song.cover_url
        })

    <span class="code-keyword">except</span> Exception <span class="code-keyword">as</span> e:
        <span class="code-keyword">return</span> jsonify({<span class="code-str">"error"</span>: str(e)}), 500</code></pre>
            </div>
          </section>

          <section>
            <h3>4. Frontend Optimization (Smart Caching)</h3>
            <p>
              Agar tidak membebani server backend setiap kali halaman dibuka, saya menerapkan strategi caching di sisi client (JavaScript):
            </p>
            <ul class="about-list">
              <li><strong>LocalStorage Cache:</strong> Metadata lagu disimpan di browser selama 7 hari.</li>
              <li><strong>Intersection Observer:</strong> Request ke backend hanya dilakukan saat user melakukan scroll ke area lagu (Lazy Loading).</li>
              <li><strong>User Intent Prefetch:</strong> Mulai mengambil data saat kursor mouse mendekati tombol play (hover/touch).</li>
            </ul>
          </section>

          <section style="margin-top: 3rem; border-top: 1px solid var(--line); padding-top: 1rem;">
            <p class="note">
              Implementasi ini menunjukkan bagaimana integrasi antara logika Backend yang kuat (Python) dan Frontend yang efisien dapat menciptakan pengalaman pengguna yang mulus.
            </p>
          </section>

        </div>
      </div>
    </div>
  </body>
</html>
